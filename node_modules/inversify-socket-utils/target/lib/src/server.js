"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InversifySocketServer = void 0;
require("reflect-metadata");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
class InversifySocketServer {
    constructor(container, server) {
        this.container = container;
        this.server = server;
    }
    build() {
        this.registerControllers();
        return this.server;
    }
    registerControllers() {
        const controllers = (0, utils_1.getControllersFromContainer)(this.container, false);
        controllers.forEach((controller) => {
            const controllerMetadata = (0, utils_1.getControllerMetadata)(controller.constructor);
            const actionMetadata = (0, utils_1.getActionMetadata)(controller.constructor);
            const parameterMetadata = (0, utils_1.getParameterMetadata)(controller.constructor);
            if (controllerMetadata && actionMetadata) {
                this.server
                    .of(controllerMetadata.namespace)
                    .on("connection", (socket) => {
                    this.handleConnection(socket, controllerMetadata, actionMetadata, parameterMetadata);
                });
            }
        });
    }
    handleConnection(socket, controllerMetadata, actionMetadata, parameterMetadata) {
        actionMetadata.forEach((metadata) => {
            if (metadata.type === constants_1.ACTION_TYPE.CONNECT) {
                this.handleAction(socket, controllerMetadata, metadata, parameterMetadata);
            }
            if (metadata.type === constants_1.ACTION_TYPE.DISCONNECT) {
                socket.on("disconnect", () => {
                    this.handleAction(socket, controllerMetadata, metadata, parameterMetadata);
                });
            }
            if (metadata.type === constants_1.ACTION_TYPE.MESSAGE) {
                socket.on(metadata.name, (payload) => {
                    this.handleAction(socket, controllerMetadata, metadata, parameterMetadata, payload);
                });
            }
        });
    }
    handleAction(socket, controller, action, parameters, payload) {
        let paramList = [];
        if (parameters) {
            paramList = parameters[action.key] || [];
        }
        const args = this.extractParams(socket, payload, paramList);
        this.container.getNamed(constants_1.TYPE.Controller, controller.target.name)[action.key](...args);
    }
    extractParams(socket, payload, params) {
        const args = [];
        params.forEach(({ type, index, name }) => {
            switch (type) {
                case constants_1.PARAMETER_TYPE.CONNECTED_SOCKET:
                    args[index] = socket;
                    return;
                case constants_1.PARAMETER_TYPE.SOCKET_IO:
                    args[index] = this.server;
                    return;
                case constants_1.PARAMETER_TYPE.SOCKET_QUERY_PARAM:
                    args[index] = socket.handshake.query[name];
                    return;
                case constants_1.PARAMETER_TYPE.SOCKET_ID:
                    args[index] = socket.id;
                    return;
                case constants_1.PARAMETER_TYPE.SOCKET_REQUEST:
                    args[index] = socket.request;
                    return;
                case constants_1.PARAMETER_TYPE.SOCKET_ROOMS:
                    args[index] = socket.rooms;
                    return;
                default:
                    args[index] = payload;
            }
        });
        return args;
    }
}
exports.InversifySocketServer = InversifySocketServer;
//# sourceMappingURL=server.js.map